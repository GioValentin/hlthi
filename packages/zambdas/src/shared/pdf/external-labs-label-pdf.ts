import { DateTime } from 'luxon';
import {
  createFilesDocumentReferences,
  EXTERNAL_LAB_LABEL_DOC_REF_DOCTYPE,
  EXTERNAL_LAB_LABEL_PDF_BASE_NAME,
  Secrets,
  getPresignedURL,
  LabelConfig,
  DYMO_550_TURBO_DPI,
} from 'utils';
import { PdfInfo, savePdfLocally, createPdfClient } from './pdf-utils';
import { PdfClientStyles, TextStyle } from './types';
import { makeZ3Url } from '../presigned-file-urls';
import { createPresignedUrl, uploadObjectToZ3 } from '../z3Utils';
import fs from 'fs';
import Oystehr from '@oystehr/sdk';
import { DocumentReference } from 'fhir/r4b';
import { randomUUID } from 'crypto';

interface ExternalLabsLabelContent {
  patientLastName: string;
  patientFirstName: string;
  patientId: string;
  patientDateOfBirth: DateTime | undefined;
  sampleCollectionDate: DateTime | undefined;
  accountNumber: string; // this is the lab provided account number. Same one used to submit the order
  orderNumber: string; // number generated by oystehr submit labs on order submit
}

export interface ExternalLabsLabelConfig {
  labelConfig: LabelConfig;
  content: ExternalLabsLabelContent;
}

const UPLOAD_BUCKET_NAME = 'visit-notes';

const convertLabeConfigToPdfClientStyles = (labelConfig: LabelConfig): PdfClientStyles => {
  const inchesToPixels = (sizeInches: number, dpi: number = DYMO_550_TURBO_DPI): number => {
    return sizeInches * dpi;
  };

  const pdfClientStyles: PdfClientStyles = {
    initialPage: {
      width: inchesToPixels(labelConfig.widthInches, labelConfig.printerDPI),
      height: inchesToPixels(labelConfig.heightInches, labelConfig.printerDPI),
      pageMargins: {
        left: inchesToPixels(labelConfig.marginLeftInches, labelConfig.printerDPI),
        right: inchesToPixels(labelConfig.marginRightInches, labelConfig.printerDPI),
        top: inchesToPixels(labelConfig.marginTopInches, labelConfig.printerDPI),
        bottom: inchesToPixels(labelConfig.marginBottomInches, labelConfig.printerDPI),
      },
    },
  };

  return pdfClientStyles;
};

const createExternalLabsLabelPdfBytes = async (data: ExternalLabsLabelConfig): Promise<Uint8Array> => {
  const { labelConfig, content } = data;

  const pdfClientStyles = convertLabeConfigToPdfClientStyles(labelConfig);

  const pdfClient = await createPdfClient(pdfClientStyles);

  // TODO: add fonts?
  const RubikFont = await pdfClient.embedFont(fs.readFileSync('./assets/Rubik-Regular.otf'));
  const RubikFontBold = await pdfClient.embedFont(fs.readFileSync('./assets/Rubik-Bold.otf'));

  // const RubikFont = await pdfClient.embedFont(
  //   fs.readFileSync('/Users/abraun/Code/ottehr/packages/zambdas/assets/Rubik-Regular.otf')
  // );
  // const RubikFontBold = await pdfClient.embedFont(
  //   fs.readFileSync('/Users/abraun/Code/ottehr/packages/zambdas/assets/Rubik-Bold.otf')
  // );
  const baseFontSize = 12;
  const baseSpacing = 6;
  const baseFieldText = {
    fontSize: baseFontSize,
    spacing: baseSpacing,
    font: RubikFont,
    newLineAfter: false,
  };

  const baseHeaderText = {
    fontSize: baseFontSize,
    font: RubikFontBold,
    spacing: baseSpacing,
  };

  const textStyles: Record<string, TextStyle> = {
    fieldTextLeft: {
      ...baseFieldText,
      side: 'left',
    },
    fieldHeaderLeft: {
      ...baseHeaderText,
      side: 'left',
    },
    fieldTextRight: {
      ...baseFieldText,
      side: 'right',
    },
    fieldHeaderRight: {
      ...baseHeaderText,
      side: 'right',
    },
  };

  // const NEWLINE_Y_DROP = 3;
  const NEWLINE_Y_DROP =
    pdfClient.getTextDimensions('Any text used to get height', textStyles.fieldHeaderLeft).height + baseSpacing;

  const truncateString = (strToTruncate: string, amountToChop: number): string => {
    if (strToTruncate.length <= amountToChop) {
      return '';
    }

    return strToTruncate.substring(0, strToTruncate.length - amountToChop);
  };

  interface Column {
    header?: string;
    value: string;
  }

  const columnGapPixels = pdfClientStyles.initialPage.width / 11;
  const leftColumnXEnd = pdfClientStyles.initialPage.width / 2 - columnGapPixels / 2;
  const rightColumnXStart = pdfClientStyles.initialPage.width / 2 + columnGapPixels / 2;
  console.log('This is columnGap: ', columnGapPixels);
  console.log('This is leftColumnXEnd: ', leftColumnXEnd);
  console.log('This is rightColumnXStart: ', rightColumnXStart);

  const drawColumnRowAndNewline = (leftColumn: Column, rightColumn: Column): void => {
    const leftHeader = leftColumn.header ? `${leftColumn.header}: ` : '';
    let leftValue = leftColumn.value;
    const widthOfLeftColumn =
      pdfClient.getTextDimensions(leftHeader, textStyles.fieldHeaderLeft).width +
      pdfClient.getTextDimensions(leftValue, textStyles.fieldTextLeft).width;

    if (widthOfLeftColumn > leftColumnXEnd) {
      // let's try truncating?
      // TODO maybe add ellipsis for emphasis?
      leftValue = truncateString(leftValue, widthOfLeftColumn - leftColumnXEnd);
    }

    let startXPos = pdfClient.getLeftBound();
    startXPos = pdfClient.drawStartXPosSpecifiedText(leftHeader, textStyles.fieldHeaderLeft, startXPos).endXPos;
    console.log('drew the left header, left off at ', startXPos);
    console.log('drawing the left value');
    pdfClient.drawStartXPosSpecifiedText(leftValue, textStyles.fieldTextLeft, startXPos);
    // pdfClient.drawText(leftValue, textStyles.fieldTextLeft);

    console.log('After drawing left column, xPos is ', pdfClient.getX());

    // This is columnGap:  61.36363636363637
    // zambdas:start: This is leftColumnXEnd:  306.8181818181818
    // zambdas:start: This is rightColumnXStart:  368.1818181818182
    // zambdas:start: After drawing left column, xPos is  18.75

    // now start the right column
    pdfClient.setX(rightColumnXStart);

    const rightHeader = rightColumn.header ? `${rightColumn.header}: ` : '';
    let rightValue = rightColumn.value;

    const widthOfRightColumn =
      pdfClient.getTextDimensions(rightHeader, textStyles.fieldHeaderRight).width +
      pdfClient.getTextDimensions(rightValue, textStyles.fieldTextRight).width;

    if (widthOfRightColumn > pdfClient.getRightBound()) {
      rightValue = truncateString(rightValue, widthOfRightColumn - pdfClient.getRightBound());
    }

    startXPos = pdfClient.drawStartXPosSpecifiedText(
      rightHeader,
      textStyles.fieldHeaderRight,
      pdfClient.getX()
    ).endXPos;
    pdfClient.drawStartXPosSpecifiedText(rightValue, textStyles.fieldTextRight, startXPos);
    // pdfClient.drawText(rightHeader, textStyles.fieldHeaderRight);
    // pdfClient.drawText(rightValue, textStyles.fieldTextRight);

    pdfClient.newLine(NEWLINE_Y_DROP);
  };

  // now we actually draw
  /* 
  Patient last name, first name
  PID
  DOB (in one column)       Collection date (in the next column)
  Account number            Order number (in the next column)
  */
  const {
    patientLastName,
    patientFirstName,
    patientId,
    patientDateOfBirth,
    sampleCollectionDate,
    accountNumber,
    orderNumber,
  } = content;
  pdfClient.drawText(`${patientLastName}, ${patientFirstName}`, textStyles.fieldHeaderLeft);
  pdfClient.newLine(NEWLINE_Y_DROP);
  // pdfClient.setX(0);

  pdfClient.drawText(`PID: ${patientId}`, textStyles.fieldTextLeft);
  pdfClient.newLine(NEWLINE_Y_DROP);
  // pdfClient.setX(0);

  drawColumnRowAndNewline(
    { header: 'DOB', value: patientDateOfBirth ? patientDateOfBirth.toFormat('MM/dd/yyyy') : '' },
    { header: 'Collected', value: sampleCollectionDate ? sampleCollectionDate.toFormat('MM/dd/yyyy') : '' }
  );
  // pdfClient.setX(0);

  drawColumnRowAndNewline({ header: 'Acct #', value: accountNumber }, { header: 'Order #', value: orderNumber });
  // pdfClient.setX(0);

  return await pdfClient.save();
};

async function createExternalLabsLabelPDFHelper(
  input: ExternalLabsLabelConfig,
  secrets: Secrets | null,
  token: string
): Promise<PdfInfo> {
  console.log('Creating external labs label pdf bytes');

  const pdfBytes = await createExternalLabsLabelPdfBytes(input).catch((error) => {
    throw new Error('failed creating external labs label pdfBytes: ' + error.message);
  });

  console.log(`Created external labs label pdf bytes`);

  const fileName = `${EXTERNAL_LAB_LABEL_PDF_BASE_NAME}-${input.content.orderNumber}.pdf`;

  console.log(`Creating base file url for file ${fileName}`);

  const baseFileUrl = makeZ3Url({
    secrets,
    fileName,
    bucketName: UPLOAD_BUCKET_NAME,
    patientID: input.content.patientId,
  });

  console.log('Uploading file to bucket');

  try {
    const presignedUrl = await createPresignedUrl(token, baseFileUrl, 'upload');
    await uploadObjectToZ3(pdfBytes, presignedUrl);
  } catch (error: any) {
    throw new Error(`failed uploading pdf ${fileName} to z3:  ${JSON.stringify(error.message)}`);
  }

  // for testing
  savePdfLocally(pdfBytes);

  return { title: fileName, uploadURL: baseFileUrl };
}

// this is what should get called in submit-lab-order
export async function createExternalLabsLabelPDF(
  labelConfig: ExternalLabsLabelConfig,
  encounterId: string,
  serviceRequestID: string,
  secrets: Secrets | null,
  token: string,
  oystehr: Oystehr
): Promise<{ docRef: DocumentReference; presignedURL: string }> {
  const pdfInfo = await createExternalLabsLabelPDFHelper(labelConfig, secrets, token);

  console.log(`this is the made pdfInfo`, JSON.stringify(pdfInfo));

  const { docRefs } = await createFilesDocumentReferences({
    files: [{ url: pdfInfo.uploadURL, title: pdfInfo.title }],
    type: { coding: [EXTERNAL_LAB_LABEL_DOC_REF_DOCTYPE], text: 'External lab sample label' },
    references: {
      subject: {
        reference: `Patient/${labelConfig.content.patientId}`,
      },
      context: {
        related: [
          {
            reference: `ServiceRequest/${serviceRequestID}`,
          },
        ],
        encounter: [{ reference: `Encounter/${encounterId}` }],
      },
    },
    docStatus: 'final',
    dateCreated: DateTime.now().setZone('UTC').toISO() ?? '',
    oystehr,
    searchParams: [{ name: 'related', value: `ServiceRequest/${serviceRequestID}` }],
    generateUUID: randomUUID,
    listResources: [], // this for whatever reason needs to get added otehrwise the function never adds the new docRef to the returned array
  });

  console.log(`These are the docRefs returned for the label: `, JSON.stringify(docRefs));

  if (!docRefs.length) {
    throw new Error('Unable to make docrefs for label');
  }

  const presignedURL = await getPresignedURL(pdfInfo.uploadURL, token);

  return { docRef: docRefs[0], presignedURL };
}
